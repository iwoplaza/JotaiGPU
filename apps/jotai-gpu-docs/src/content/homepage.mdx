import CautionIcon from '../components/CautionIcon.astro';

<span className="text-white">JotaiGPU</span> â€” a toolkit for building declarative data graphs, spanning across your CPU and GPU, with automatic
dependency tracking. It's built on top of *[Jotai](https://jotai.org)* and *[TypeGPU](https://typegpu.com)*, allowing
your entire data pipeline to be written in TypeScript, both the CPU and GPU portions.

<aside className='px-5 py-0.5 my-6 bg-accent-900'>
<p className='flex items-center gap-2'><CautionIcon /><strong>Limited WebGPU Support</strong></p>
The WebGPU API, which is the basis for technologies like *[TypeGPU](https://typegpu.com)*, is yet to be widely supported by browsers.
Interactive examples might not work for you.
</aside>

Let's look at an interactive example.

```ts twoslash
import { atom, createStore } from 'jotai';
import * as d from 'typegpu/data';
import { withUpload, gpuAtom } from 'jotai-gpu';

const store = createStore();

// ---cut---
// Vanilla atoms can be decorated with a WGSL schema, allowing
// their value to be uploaded to the GPU
const countAtom = withUpload(d.f32, atom(1));

// GPU atoms compute their value on the GPU. They can derive
// other GPU atoms, or `withUpload(...)` decorated atoms
const doubleAtom = gpuAtom(d.f32)(() => {
  'kernel'; // <- this function is executable on the GPU
  return countAtom.$ * 2;
});

// GPU atoms are just asynchronous atoms from the perspective
// of vanilla atoms, so we can download the result and derive it
const quadAtom = atom(async (get) => {
  return (await get(doubleAtom)) * 2;
});

// Listening to changes of `quadAtom`. There are also
// easy bindings for frameworks like React
store.sub(quadAtom, async () => {
  console.log(await store.get(quadAtom));
});
```